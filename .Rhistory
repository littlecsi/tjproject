teX <- teData[,c(1:11)]
nnModel <- nnet(x=trX, y=trY, size=15, softmax=T)
plot.nnet(nnModel)
nnPrediction <- predict(nnModel, teX, type="class")
predTable <- table(nnPrediction, teData$section)
predAccuracy <- cat(calcAcc(predTable), "%\n")
# neuralnet package
Elen <- nrow(subset(NewsData, section == "Economy"))
Ilen <- nrow(subset(NewsData, section == "IT"))
Llen <- nrow(subset(NewsData, section == "Life_Cult"))
Plen <- nrow(subset(NewsData, section == "Politics"))
Slen <- nrow(subset(NewsData, section == "Society"))
Wlen <- nrow(subset(NewsData, section == "World"))
Ei <- sample(c(1:Elen), 0.75*Elen); Ii <- sample(c(1:Ilen), 0.75*Ilen); Li <- sample(c(1:Llen), 0.75*Llen);
Pi <- sample(c(1:Plen), 0.75*Plen); Si <- sample(c(1:Slen), 0.75*Slen); Wi <- sample(c(1:Wlen), 0.75*Wlen);
idx <- c(
Ei,
Ii + Elen,
Li + Elen + Ilen,
Pi + Elen + Ilen + Llen,
Si + Elen + Ilen + Llen + Plen,
Wi + Elen + Ilen + Llen + Plen + Slen
)
NewsDataN <- data.frame(as.vector(scale(NewsData[,1])))
for(i in c(2:11)) {
vec <- as.vector(scale(NewsData[,i]))
t_df <- data.frame(vec)
NewsDataN <- cbind(NewsDataN, t_df)
}
NewsDataN$section <- NewsData[,12]
colnames(NewsDataN) <- colnames(NewsData)
trData <- NewsDataN[idx,]
teData <- NewsDataN[-idx,]
nnFormula <- section ~ .
nnModel2 <- neuralnet(formula=nnFormula, data=trData, hidden=10)
plot(nnModel2)
nnModel2Result <- compute(nnModel2, teData[,c(1:11)])
nnPrediction2 <- nnModel2Result$net.result
nndf <- data.frame(predict=nnPrediction2, real=teData["section"])
x <- seq(1:length(nnPrediction2))
plot(x=x, y=nnPrediction2, type="n", xlab="", ylab="value")
points(x, nnPrediction2, pch=4, col="red")
points(x, teData["section"], pch=1, col="blue")
legend("bottomright", legend=c("prediction", "answer"), pch=c(4,1))
cor(nnPrediction2, teData["section"])
trData
head(trData)
lapply(NewsData, normalize)
lapply(NewsData, normalization)
lapply(NewsData[,-12], normalization)
scale(NewsData[,-12])
NewsDataN <- as.data.frame(lapply(NewsData[,-12], normalization))
NewsDataN$section <- NewsData[,12]
colnames(NewsDataN) <- colnames(NewsData)
str(NewsDataN)
summary(NewsDataN)
trData <- NewsDataN[idx,]
teData <- NewsDataN[-idx,]
nnFormula <- section ~ .
nnModel2 <- neuralnet(formula=nnFormula, data=trData, hidden=10)
Ei <- sample(c(1:Elen), 0.1*Elen); Ii <- sample(c(1:Ilen), 0.1*Ilen); Li <- sample(c(1:Llen), 0.1*Llen);
Pi <- sample(c(1:Plen), 0.1*Plen); Si <- sample(c(1:Slen), 0.1*Slen); Wi <- sample(c(1:Wlen), 0.1*Wlen);
idx <- c(
Ei,
Ii + Elen,
Li + Elen + Ilen,
Pi + Elen + Ilen + Llen,
Si + Elen + Ilen + Llen + Plen,
Wi + Elen + Ilen + Llen + Plen + Slen
)
NewsDataN <- as.data.frame(lapply(NewsData[,-12], normalization))
NewsDataN$section <- NewsData[,12]
colnames(NewsDataN) <- colnames(NewsData)
trData <- NewsDataN[idx,]
teData <- NewsDataN[-idx,]
nnFormula <- section ~ .
nnModel2 <- neuralnet(formula=nnFormula, data=trData, hidden=10)
nnModel2 <- neuralnet(formula=nnFormula, data=trData, hidden=5)
install.packages("openxlsx")
install.packages("openxlsx")
install.packages("openxlsx")
install.packages("devtools")
install.packages("nnet")
install.packages("neuralnet")
####################################################################################################
# Library
library(openxlsx)
library(dplyr)
library(e1071)
library(klaR)
library(kernlab)
####################################################################################################
# Variable
pathOne <- "D:/GitHub/tjproject/resources/"
sections <- c("econ", "IT", "life_cult", "politics", "soc", "world")
Csections <- c("Economy", "IT", "Life_Cult", "Politics", "Society", "World")
####################################################################################################
# Function
getData <- function(path, n) {
df <- data.frame()
for(i in c(1:n)) {
dfOne <- read.xlsx(path, sheet=i, colNames=T, rowNames=F)
df <- rbind(df, dfOne)
}
return(df)
}
getAllSectionData <- function(section) {
path1 <- paste(pathOne, section, "/2018_comment_data_", section, ".xlsx", sep="")
dfOne <- getData(path1, 2)
path2 <- paste(pathOne, section, "/2019_comment_data_", section, ".xlsx", sep="")
dfTwo <- getData(path2, 10)
path3 <- paste(pathOne, section, "/2018_view_data_", section, ".xlsx", sep="")
dfThree <- getData(path3, 2)
path4 <- paste(pathOne, section, "/2019_view_data_", section, ".xlsx", sep="")
dfFour <- getData(path4, 10)
df <- rbind(dfOne[-5], dfTwo[-5], dfThree[-5], dfFour[-5])
return(df)
}
getcolumns <- function(data, columns) {
len <- length(columns)
# cat(len, '\n')
if(len > 1) {
df <- data[columns[1]]
for(i in c(2:len)) {
df <- cbind(df, data[columns[i]])
}
} else { df <- data %>% select(columns) }
return(df)
}
getTAcc <- function(table) {
true <- table["TRUE"]
accuracy <- as.numeric(round(true/sum(table)*100, 2))
return(accuracy)
}
####################################################################################################
# Main
# Collect Data
Edf <- getAllSectionData(sections[1])
Idf <- getAllSectionData(sections[2])
Ldf <- getAllSectionData(sections[3])
Pdf <- getAllSectionData(sections[4])
Sdf <- getAllSectionData(sections[5])
Wdf <- getAllSectionData(sections[6])
# Get needed columns
reqCol <- c("currCmt","deleted","brokenPolicy","maleRatio","femaleRatio","X10","X20","X30","X40","X50","X60")
Edata <- getcolumns(Edf, reqCol)
Idata <- getcolumns(Idf, reqCol)
Ldata <- getcolumns(Ldf, reqCol)
Pdata <- getcolumns(Pdf, reqCol)
Sdata <- getcolumns(Sdf, reqCol)
Wdata <- getcolumns(Wdf, reqCol)
# Add its own section into a column
Edata$section <- "Economy"; Idata$section <- "IT"; Ldata$section <- "Life_Cult";
Pdata$section <- "Politics"; Sdata$section <- "Society"; Wdata$section <- "World";
# Collect into one massive column
NewsData <- rbind(Edata, Idata, Ldata, Pdata, Sdata, Wdata)
colnames(NewsData)
# Remove NAs
NewsData <- na.omit(NewsData)
# Change all Independent Variables to numeric
NewsData$currCmt <- as.numeric(NewsData$currCmt)
NewsData$deleted <- as.numeric(NewsData$deleted)
NewsData$brokenPolicy <- as.numeric(NewsData$brokenPolicy)
# Data Extract
Elen <- nrow(subset(NewsData, section == "Economy"))
Ilen <- nrow(subset(NewsData, section == "IT"))
Llen <- nrow(subset(NewsData, section == "Life_Cult"))
Plen <- nrow(subset(NewsData, section == "Politics"))
Slen <- nrow(subset(NewsData, section == "Society"))
Wlen <- nrow(subset(NewsData, section == "World"))
Ei <- sample(c(1:Elen), 0.8*Elen); Ii <- sample(c(1:Ilen), 0.8*Ilen); Li <- sample(c(1:Llen), 0.8*Llen);
Pi <- sample(c(1:Plen), 0.8*Plen); Si <- sample(c(1:Slen), 0.8*Slen); Wi <- sample(c(1:Wlen), 0.8*Wlen);
idx <- c(
Ei,
Ii + Elen,
Li + Elen + Ilen,
Pi + Elen + Ilen + Llen,
Si + Elen + Ilen + Llen + Plen,
Wi + Elen + Ilen + Llen + Plen + Slen
)
# Create Training and Testing Data
trData <- NewsData[ idx,]
teData <- NewsData[-idx,]
svmFormula <- section ~ .
##################################################
# 적절한 파라미터 찾기
param <- tune(svm, Species ~ ., data=iris, gamma=2^(-1:1), cost=2^(2:4))
attributes(param)
param$best.model
# rbfdot
rbfModel <- ksvm(svmFormula, data=trData, kernel="rbfdot")
rbfPred <- predict(rbfModel, teData)
rbfTable <- table(rbfPred, teData$section)
rbfTable
rbfResult <- rbfPred == teData$section
rbfResultT <- table(rbfResult)
rbfAcc <- getTAcc(rbfResultT)
rbfAcc
plot(rbfModel)
nrow(Edf)
nrow(NewsData)
####################################################################################################
# Database
####################################################################################################
library(DBI)
library(RMySQL)
library(stringr)
library(openxlsx)
# host : '%'를 넣으면 외부접속, 내부 접속일 경우는 localhost를 넣는다.
## localhost일 경우 포트를 지정하지 않아도 작동한다.
conn<-dbConnect(MySQL(), user="root", password="1q2w3e4r!", dbname="naverdb",host="localhost")
# Test용 dual 테이블
## 결과가 나오면 정상적으로 작동하는 것을 확인할 수 있다.
query01 <- 'select power(2, 10) from dual'
data <- dbGetQuery(conn, query01)
data
####################################################################################################
# Initialise Variables
ext <- '.xlsx'
path <- 'resources/'
types <- c('E','I','L','P','S','W')
sections <- c('econ','IT','life_cult','politics','soc','world')
tables <- c('NEWS_ECON', 'NEWS_IT', 'NEWS_LIFE_CULT', 'NEWS_POLITICS', 'NEWS_SOC', 'NEWS_WORLD')
####################################################################################################
# functions
dbsend <- function(df, type, section, tab) {
cat('dbsend()\n')
len <- nrow(df)
date <- df$date
TITLE <- df$title
SUBTITLE <- df$subti
SRC <- df$source
NEWSDATE <- c()
for(l in c(1:len)) {
DATE <- paste(str_sub(date[l], 1, 4), '/', str_sub(date[l], 5, 6), '/', str_sub(date[l], 7, 8), sep='')
NEWSDATE <- c(NEWSDATE, DATE)
}
NVIEW <- df$view
NCOMMENT <- df$cmt
CURR_CMT <- df$currCmt
DELETED <- df$deleted
BROKEN <- df$brokenPolicy
MALER <- df$maleRatio
FEMALER <- df$femaleRatio
X10 <- df$X10; X20 <- df$X20; X30 <- df$X30; X40 <- df$X40; X50 <- df$X50; X60 <- df$X60
NEWSID <- c()
NEWSRANK <- df$rank
if(is.null(NVIEW)) {
NVIEW <- rep(0, len)
for(l in c(1:len)) {
ID <- paste(type, 'C', date[l], NEWSRANK[l], sep='')
# cat(ID, '\n')
NEWSID <- c(NEWSID, ID)
}
}
else {
NCOMMENT <- rep(0, len)
for(l in c(1:len)) {
ID <- paste(type, 'V', date[l], NEWSRANK[l], sep='')
# cat(ID, '\n')
NEWSID <- c(NEWSID, ID)
}
}
for(i in c(1:len)) {
if(is.na(X10[i])) {
MALER[i] <- 0
FEMALER[i] <- 0
X10[i] <- 0
X20[i] <- 0
X30[i] <- 0
X40[i] <- 0
X50[i] <- 0
X60[i] <- 0
}
}
for(i in c(1:len)) {
if(is.na(CURR_CMT[i])) {
CURR_CMT[i] <- 0
DELETED[i] <- 0
BROKEN[i] <- 0
}
}
# cat(NEWSID, '\n')
for(l in c(1:len)) {
# cat(NEWSID[l], '\n')
query <- paste("INSERT INTO ", tab, " VALUES(\'", NEWSID[l], '\', ', NEWSRANK[l], ', \'', TITLE[l], '\',\'', SUBTITLE[l], '\',\'',  SRC[l], '\',\'', NEWSDATE[l], '\', ', NVIEW[l], ', ', NCOMMENT[l], ', ', CURR_CMT[l], ', ', DELETED[l], ', ', BROKEN[l], ', ', MALER[l], ', ', FEMALER[l], ', ', X10[l], ', ', X20[l], ', ', X30[l], ', ', X40[l], ', ', X50[l], ', ', X60[l], ")", sep='')
# cat(query, '\n')
dbSendQuery(conn, query)
}
}
cleanData <- function(df) {
df$title <- str_replace_all(df$title, '\"', ' ')
df$title <- str_replace_all(df$title, ',', ' ')
df$title <- str_replace_all(df$title, '\'', ' ')
df$title <- str_replace_all(df$title, '\t', '')
df$subti <- str_replace_all(df$subti, '\"', ' ')
df$subti <- str_replace_all(df$subti, ',', ' ')
df$subti <- str_replace_all(df$subti, '\'', ' ')
df$subti <- str_replace_all(df$subti, '\t', '')
return(df)
}
####################################################################################################
# Main
for(i in c(1:6)) {
i <- 1
type <- types[i]
section <- sections[i]
tab <- tables[i]
fpath <- paste(path, section, '/2018_view_data_', section, ext, sep='')
for(i in c(1:2)) {
df <- read.xlsx(fpath, sheet=i, colNames=T, rowNames=F)
df <- cleanData(df)
dbsend(df, type, section, tab)
cat('-', i, '-\n')
}
fpath <- paste(path, section, '/2018_comment_data_', section, ext, sep='')
for(i in c(1:2)) {
df <- read.xlsx(fpath, sheet=i, colNames=T, rowNames=F)
df <- cleanData(df)
dbsend(df, type, section, tab)
cat('-', i, '-\n')
}
fpath <- paste(path, section, '/2019_view_data_', section, ext, sep='')
for(i in c(1:10)) {
df <- read.xlsx(fpath, sheet=i, colNames=T, rowNames=F)
df <- cleanData(df)
dbsend(df, type, section, tab)
cat('-', i, '-\n')
}
fpath <- paste(path, section, '/2019_comment_data_', section, ext, sep='')
for(i in c(1:10)) {
df <- read.xlsx(fpath, sheet=i, colNames=T, rowNames=F)
df <- cleanData(df)
dbsend(df, type, section, tab)
cat('-', i, '-\n')
}
}
query01 <- 'select * from news_econ'
data <- dbGetQuery(conn, query01)
data
head(data, 1)
####################################################################################################
# Database
####################################################################################################
library(DBI)
library(RMySQL)
library(stringr)
library(openxlsx)
# host : '%'를 넣으면 외부접속, 내부 접속일 경우는 localhost를 넣는다.
## localhost일 경우 포트를 지정하지 않아도 작동한다.
conn<-dbConnect(MySQL(), user="root", password="1q2w3e4r!", dbname="naverdb",host="localhost")
# Test용 dual 테이블
## 결과가 나오면 정상적으로 작동하는 것을 확인할 수 있다.
query01 <- 'select power(2, 10) from dual'
data <- dbGetQuery(conn, query01)
####################################################################################################
# Initialise Variables
ext <- '.xlsx'
path <- 'resources/'
types <- c('E','I','L','P','S','W')
sections <- c('econ','IT','life_cult','politics','soc','world')
tables <- c('NEWS_ECON', 'NEWS_IT', 'NEWS_LIFE_CULT', 'NEWS_POLITICS', 'NEWS_SOC', 'NEWS_WORLD')
####################################################################################################
dbDisconnectAll <- function(){
ile <- length(dbListConnections(MySQL())  )
lapply( dbListConnections(MySQL()), function(x) dbDisconnect(x) )
cat(sprintf("%s connection(s) closed.\n", ile))
}
# clean function
## param : data frame
cleanData <- function(df) {
df$title <- str_replace_all(df$title, '\"', ' ')
df$title <- str_replace_all(df$title, ',', ' ')
df$title <- str_replace_all(df$title, '\'', ' ')
df$title <- str_replace_all(df$title, '\t', '')
df$subti <- str_replace_all(df$subti, '\"', ' ')
df$subti <- str_replace_all(df$subti, ',', ' ')
df$subti <- str_replace_all(df$subti, '\'', ' ')
df$subti <- str_replace_all(df$subti, '\t', '')
return(df)
}
# functions
dbsend <- function(df, type, section, tab) {
cat('dbsend()\n')
len <- nrow(df)
date <- df$date
TITLE <- df$title
SUBTITLE <- df$subti
SRC <- df$source
NEWSDATE <- c()
for(l in c(1:len)) {
DATE <- paste(str_sub(date[l], 1, 4), '/', str_sub(date[l], 5, 6), '/', str_sub(date[l], 7, 8), sep='')
NEWSDATE <- c(NEWSDATE, DATE)
}
NVIEW <- df$view
NCOMMENT <- df$cmt
CURR_CMT <- df$currCmt
DELETED <- df$deleted
BROKEN <- df$brokenPolicy
MALER <- df$maleRatio
FEMALER <- df$femaleRatio
X10 <- df$X10; X20 <- df$X20; X30 <- df$X30; X40 <- df$X40; X50 <- df$X50; X60 <- df$X60
NEWSID <- c()
NEWSRANK <- df$rank
if(is.null(NVIEW)) {
NVIEW <- rep(0, len)
for(l in c(1:len)) {
ID <- paste(type, 'C', date[l], NEWSRANK[l], sep='')
# cat(ID, '\n')
NEWSID <- c(NEWSID, ID)
}
}
else {
NCOMMENT <- rep(0, len)
for(l in c(1:len)) {
ID <- paste(type, 'V', date[l], NEWSRANK[l], sep='')
# cat(ID, '\n')
NEWSID <- c(NEWSID, ID)
}
}
for(i in c(1:len)) {
if(is.na(X10[i])) {
MALER[i] <- 0
FEMALER[i] <- 0
X10[i] <- 0
X20[i] <- 0
X30[i] <- 0
X40[i] <- 0
X50[i] <- 0
X60[i] <- 0
}
}
for(i in c(1:len)) {
if(is.na(CURR_CMT[i])) {
CURR_CMT[i] <- 0
DELETED[i] <- 0
BROKEN[i] <- 0
}
}
# cat(NEWSID, '\n')
for(l in c(1:len)) {
# cat(NEWSID[l], '\n')
query <- paste("INSERT INTO ", tab, " VALUES(\'", NEWSID[l], '\', ', NEWSRANK[l], ', \'', TITLE[l], '\',\'', SUBTITLE[l], '\',\'',  SRC[l], '\',\'', NEWSDATE[l], '\', ', NVIEW[l], ', ', NCOMMENT[l], ', ', CURR_CMT[l], ', ', DELETED[l], ', ', BROKEN[l], ', ', MALER[l], ', ', FEMALER[l], ', ', X10[l], ', ', X20[l], ', ', X30[l], ', ', X40[l], ', ', X50[l], ', ', X60[l], ")", sep='')
# cat(query, '\n')
dbSendQuery(conn, query)
}
}
####################################################################################################
# Main
for(i in c(1:6)) {
type <- types[i]
section <- sections[i]
tab <- tables[i]
fpath <- paste(path, section, '/2018_view_data_', section, ext, sep='')
for(i in c(1:2)) {
df <- read.xlsx(fpath, sheet=i, colNames=T, rowNames=F)
df <- cleanData(df)
dbsend(df, type, section, tab)
cat('-', i, '-\n')
}
fpath <- paste(path, section, '/2018_comment_data_', section, ext, sep='')
for(i in c(1:2)) {
df <- read.xlsx(fpath, sheet=i, colNames=T, rowNames=F)
df <- cleanData(df)
dbsend(df, type, section, tab)
cat('-', i, '-\n')
}
fpath <- paste(path, section, '/2019_view_data_', section, ext, sep='')
for(i in c(1:10)) {
df <- read.xlsx(fpath, sheet=i, colNames=T, rowNames=F)
df <- cleanData(df)
dbsend(df, type, section, tab)
cat('-', i, '-\n')
}
fpath <- paste(path, section, '/2019_comment_data_', section, ext, sep='')
for(i in c(1:10)) {
df <- read.xlsx(fpath, sheet=i, colNames=T, rowNames=F)
df <- cleanData(df)
dbsend(df, type, section, tab)
cat('-', i, '-\n')
}
}
# query01 <- 'select * from news_politics'
# data <- dbGetQuery(conn, query01)
dbDisconnectAll()
query01 <- 'select * from news_politics'
data <- dbGetQuery(conn, query01)
# host : '%'를 넣으면 외부접속, 내부 접속일 경우는 localhost를 넣는다.
## localhost일 경우 포트를 지정하지 않아도 작동한다.
conn<-dbConnect(MySQL(), user="root", password="1q2w3e4r!", dbname="naverdb",host="localhost")
query01 <- 'select * from news_politics'
data <- dbGetQuery(conn, query01)
view(data)
View(data)
dbGetQuery(conn, "set names utf8")
data <- dbGetQuery(conn, query01)
View(data)
dbGetQuery(conn, "set names utf8mb4)
View(data)
dbDisconnectAll()
dbGetQuery(conn, "set names utf8mb4")
dbGetQuery(conn, "set names utf8mb4")
View(data)
data <- dbGetQuery(conn, query01)
data
query01 <- 'select * from news_politics'
data <- dbGetQuery(conn, query01)
View(data)
class(data)
write.csv(head(df), "jebal.csv", fileEncoding = "utf8")
write.csv(head(df), "jebal.csv", fileEncoding = "euc-kr")
write.csv(head(df), "jebal.csv", fileEncoding = "cp949")
